# Мини-бюджеты (подбюджеты по категориям)

Документ описывает новую функцию мини-бюджетов, опираясь на текущую концепцию ExGo: локальное хранилище (AsyncStorage), стейт-провайдеры Settings/Transactions, донат на Home и экран Spending Breakdown (Details).

## Цель и ценность
- Пользователь задаёт отдельный месячный лимит для каждой важной статьи расходов (топливо, питание, карманные деньги).
- В любой момент видит «X из Y» и остаток по категории, чтобы не выходить за план.
- Расходы автоматически списываются из связанного мини-бюджета в момент добавления транзакции.

## UX и пользовательский поток
- Точка входа: плавающая кнопка «+» получает новый пункт «Category budget» (или «Mini budget»). Название уточняется, главное — интуитивно для англоязычного пользователя.
- Модал создания мини-бюджета:
  - Поля: Name (required), Monthly limit (required, >0), Linked categories (multi-select), Optional note.
  - Период: текущий месяц (month key YYYY-MM). При переходе месяца создаётся новое состояние для тех же категорий с тем же лимитом.
- Экран Spending Breakdown (Details) расширяется:
  - Список карточек мини-бюджетов: заголовок, прогресс-бар, «spent/limit», остаток, статус (ok/warning/over).
  - Деталка карточки: транзакции, темп (spent per day), прогноз до конца месяца.
  - CTA: Edit, Delete.
- Добавление расхода:
  - Если категория входит в мини-бюджет, расход прибавляется к `spent` этого бюджета в месяце транзакции.
  - Если категория в нескольких мини-бюджетах — предпочтительно выбрать стратегию «одна категория = один мини-бюджет» в v1 (см. открытые вопросы).
- Донат на Home и Breakdown:
  - При выборе сегмента категории отображаем остаток «X из Y» и статус мини-бюджета, если он есть.
  - В отдельном окне «Spending breakdown» мини-планы показываются даже без выбранной категории.

## Данные и модели
- Новый тип `MiniBudget`:
  - `id`, `userId`
  - `name` (string)
  - `month` (string, YYYY-MM)
  - `currency` (наследуем из settings)
  - `limitAmount` (number)
  - `linkedCategoryIds: string[]`
  - `status: 'active' | 'archived'`
  - `createdAt`, `updatedAt`
- Производные поля (monthly state):
  - `spentAmount` (сумма расходов по связанным категориям за указанный месяц)
  - `remaining = limitAmount - spentAmount`
  - `pace` (spent / daysElapsed), `forecast` (pace * daysInMonth)
  - `state: 'ok' | 'warning' | 'over'` по порогам темпа и превышения лимита.

## Хранилище и стейт
- AsyncStorage:
  - Новый ключ `miniBudgets` для массива `MiniBudget` (метаданные).
  - Кэш состояния на месяц `miniBudgetMonthlyState` (опционально) для быстрой отрисовки; пересчитывается при изменениях.
- Стейт-слой:
  - `MiniBudgetsProvider` (по аналогии с Settings/Transactions) с методами `create`, `update`, `delete`, `listByMonth`, `recalcForMonth`.
  - Селекторы: `useMiniBudgets(month)`, `useMiniBudgetByCategory(categoryId, month)`.
  - Интеграция с `TransactionsProvider`: хук/сайд-эффект на создание/обновление/удаление транзакции → инкремент/декремент `spentAmount` нужного мини-бюджета.

## Бизнес-правила
- Категория должна быть в хотя бы одном мини-бюджете? — нет, по умолчанию не обязана; если не входит, транзакция не учитывается в мини-бюджетах.
- Мини-бюджет живёт в рамках месяца; при смене месяца создаётся новое состояние (spent=0, limit=прежний).
- Валюта берётся из текущих настроек; смена валюты требует пересоздания или пересчёта (зафиксировать предупреждение в UI).
- Лимит > 0; если требуется «запрет трат», можно отдельно обсудить лимит=0 (см. вопросы).
- При редактировании списка категорий пересчитываем `spentAmount` за текущий месяц на основе транзакций.
- При удалении мини-бюджета храним только транзакции; агрегаты удаляются.

## Изменения в существующих функциях
- Add Transaction Flow:
  - После сохранения расхода вызывается `applyExpenseToMiniBudgets(tx)` → обновление `spentAmount`.
  - При изменении категории/даты/суммы в уже созданной транзакции делаем корректировку старого и нового бюджета/месяца.
  - При удалении транзакции откатываем `spentAmount`.
- Donut/Details:
  - Добавить отображение статуса мини-бюджета для выбранной категории.
  - В Details добавить секцию «Mini budgets» (карточки прогресса).
- Notifications/alerts (если включены):
  - Триггеры `warning` (темп выше плана) и `over` (превышен лимит) с ин-апп баннерами.

## API слоя данных (локальный контракт)
- `createMiniBudget(input)` → сохраняет в `miniBudgets`, инициализирует state для текущего месяца.
- `getMiniBudgetsByMonth(month)` → возвращает массив с агрегатами.
- `updateMiniBudget(id, patch)` → обновляет метаданные, пересчитывает state.
- `deleteMiniBudget(id)` → удаляет метаданные и state.
- `applyExpenseToMiniBudgets(tx)` / `revertExpenseFromMiniBudgets(tx)` → вызываются из `TransactionsProvider`.

## Аналитика
- `mini_budget_created {countCategories, limitAmount}`
- `mini_budget_edited {fieldsChanged}`
- `mini_budget_deleted`
- `mini_budget_viewed` (экран Spending Breakdown)
- `mini_budget_progress_viewed {budgetId}`
- `mini_budget_alert_shown {type: warning|over}`
- `expense_added_to_minibudget {budgetId, amount}`
- `expense_reclassified_between_minibudgets`

## План внедрения (v1)
1) Модели и хранилище: типы, AsyncStorage ключи, провайдер, пересчёт из транзакций.
2) Интеграция транзакций: инкремент/декремент при create/update/delete.
3) UI:
   - Новый пункт в FAB.
   - Модал создания/редактирования мини-бюджета.
   - Секция «Mini budgets» на Details, badge/статус в Home при выборе категории.
4) Алерты и аналитика: трекеры событий, баннеры предупреждений.
5) Полировка: валидация форм, пустые состояния, доступность.

## Открытые вопросы
1) Разрешаем ли категории входить в несколько мини-бюджетов? Если да, как делить расход (строго один бюджет, выбор при добавлении, пропорция лимитов)? Рекомендация v1: один бюджет на категорию.
2) Лимит = 0 трактуем как «запрет трат» или запрещаем такие бюджеты?
3) Какое точное название пункта в FAB на английском: «Mini budget», «Category budget» или «Recurring spend»?
4) При смене валюты в настройках пересчитываем лимиты/остатки или просим пересоздать бюджеты?
